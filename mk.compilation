
ifndef __mk_compilation_included
__mk_compilation_included := true

include $(dir $(lastword $(MAKEFILE_LIST)))mk.base


#-- set/modify public definitions --

mk_PARAMETERS   += BUILD_MODE CFG ARCH TAG BUILD_DIR OUT_TYPE OUT_DIR OUT_NAME OUT_FILE_NAME OUT_FILE OUT_UMASK SUBPACKAGES
mk_OPT_CLASSES  += BUILD_MODE CFG ARCH
mk_TARGET_list  += built clean grep,* $(TARGETS)
mk_FILE_TYPES   += 
mk_OUTPUT_DIRS  += $(mk_BUILD_DIR) $(mk_OUT_DIR)

DEPS_              ?= .mk.deps
mk_DEPS             = $(mk_BUILD_DIR)/$(notdir $(DEPS_))
mk_DEPS_info        = $(notdir $(mk_pwd))  [$1] @ $(mk_now)
mk_SOURCE_LIST_FILE = $(mk_BUILD_DIR)/.mk.sourcelist
mk_OBJECT_ARCHIVE   = .mk.objects.a


mk_OUT_TYPE_list   += static shared exe
mk_BUILD_MODE_list += $(mk_OUT_TYPE_list)
mk_ARCH_list       +=
mk_CFG_list         = $(CONFIGURATIONS)
mk_FILE_PATTERNS    = $(sort $(FILE_PATTERNS) $(mk_FILE_TYPES:%=*.%))
mk_FILE_PATTERNS_RE = $(sort $(FILE_PATTERNS_RE))
mk_OPT_list         = $(filter-out BUILD_MODE,$(mk_OPT_CLASSES))
mk_OPT_CLASS_list   = $(sort $(mk_OPT_CLASSES) mk_ANY)

mk_tags             = $(foreach c,$(filter-out $1,$(mk_OPT_CLASS_list)),$($1.$(call mk_val,$c)))
mk_get              = $(or $($1),$(strip $(call mk_tags,$(notdir $1))),$($1_default))
mk_fileType_opts    = $(call mk_pattern_opts,mk_FILE_PATTERNS,$1) $(call mk_patternRE_opts,mk_FILE_PATTERNS_RE,$1)
mk_object_of        = $(patsubst %,$(mk_BUILD_DIR)/%.o,$(notdir $(basename $(1))))
mk_variant_of       = $(dir $1).mk.compilation.variant.$(notdir $1)#$(mk_BUILD_DIR)/variant.$(notdir $1)
mk_chain_args       = $(subst ' -,' -$1 -,$2)
mk_list_multisource = $(call ___object_source_of,$(notdir $(mk_OBJECTS)),$(call mk_path,$(mk_SOURCE_FILES)),$2,$(or $1,multiple source files for))
___source_files_of  = $(call mk_grep,/$(basename $1).,$2)
___object_source_of = $(strip \
                        $(foreach o,$(sort $1),  \
                          $(if $(filter-out 1,$(call mk_count,$o,$1)), \
                            $(call $(or $3,mk_args),$4 $o: [$(call ___source_files_of,$o,$2)]))))

any_source          = $(foreach t,$(mk_FILE_TYPES),$(wildcard *.$(t)))
any_source_in       = $(foreach t,$(mk_FILE_TYPES),$(wildcard $(call mk_norm_dir,$1)/*.$(t)))
scan_source         = $(foreach d,$(mk_SOURCE_DIRS),$(call any_source_in,$d))

scan_file_pattern   = $(call mk_chain_args,or,$(foreach x,$(mk_FILE_TYPES),-name '*.$x'))
ignore_dir_pattern  = $(call mk_chain_args,or,$(foreach x,$(mk_IGNORE_DIRS),-path '*/$x/*') -path '*/.*')
scan_files_in       = $(shell find -L $1 \( $(scan_file_pattern) \) -and -not \( $(ignore_dir_pattern) \))
scan_source_dirs    = $(call mk_norm_dir,$(sort $(dir $(call scan_files_in,$1))))
filter_source_in    = $(filter $1/%,$(mk_SOURCE_FILES))
strip_source_in     = $(patsubst $1/%,%,$(call filter_source_in,$1))

svn_revision       := $(shell svn info | sed -ne 's/^Revision: //p')
svn_modified       := $(shell svn st | grep "^M " | awk '{print $$NF}')
svn_modified_tab    = $(call mk_join,\\\n,$(svn_modified))

define mk_packages
$(if $(mk_SUBPACKAGES),\
	@$(mk_echo) ''$(call mk_frame,make $1 @ subpackages)         \
	$(call mk_submake,$1 $(mk_MAKEFLAGS) -C,$(mk_SUBPACKAGES),1) \
	@$(mk_echo) )
endef

# $(call mk_symlink_so,SO_FILENAME)
define mk_symlink_so
	$(call mk_link,$(notdir $1) $(basename $1) $(notdir $1) $(basename $(basename $1)))
endef

# $(call mk_collect_so,LIB_DIRS,SO_NAMES[,TARGET_DIR])
define mk_collect_so
	$(eval ___find_pattern := $(subst ' -,' -or -,$(foreach l,$2,-wholename '*$l*.so*')))
	$(if $(and $1,$2),\
    find $1 \( $(___find_pattern) \) -and -not -path '*/.*' -exec cp -a {} $(or $3,$(mk_OUT_DIR)) \; $(mk_ignoreErrors))
endef

# $(call mk_archive_objects,ARCHIVE)
define mk_archive_objects
	cd $(mk_BUILD_DIR) &&\
		$(call mk_logged_cmd,ar rs $1 $(sort $(notdir $(mk_OBJECTS)))) &&\
	cd -
endef

#-- user parameters --

CONFIGURATIONS        ?= debug release
debug_doc             ?= shortcut target for building with debug options. Equivalent to: "make built CFG=debug"
release_doc           ?= shortcut target for building with optimization and without debug options. Equivalent to: "make built CFG=release"

ARCH_doc              ?= architecture id: $(call mk_opt_set,ARCH)
ARCH_default           = $(firstword $(call uniq,$(mk_ARCH_list)))
mk_ARCH                = $(call mk_get,ARCH)

CFG_doc               ?= current build configuration: $(call mk_opt_set,CFG)
CFG_default            = $(firstword $(mk_CFG_list))
mk_CFG                 = $(call mk_get,CFG)

TAG_doc               ?= string for tagging build directory.
TAG_default            = $(subst $(mk_SPACE),.,$(foreach t,$(mk_OPT_list),$(mk_$t)))
mk_TAG                 = $(call mk_get,TAG)

mk_BUILT_TYPE_NAME     = $(__built_type_$(mk_OUT_TYPE))
__built_type_exe       = APPLICATION
__built_type_shared    = SHARED_LIB
__built_type_static    = STATIC_LIB

BUILD_MODE_doc        ?= mode for building object files: $(call mk_opt_set,BUILD_MODE)
BUILD_MODE_default     = $(mk_OUT_TYPE)
mk_BUILD_MODE          = $(call mk_get,BUILD_MODE)

BUILD_DIR_doc         ?= working directory for building object files.
BUILD_DIR_default      = $(mk_TAG).$(mk_BUILD_MODE)
mk_BUILD_DIR           = $(or $(BUILD_DIR),.work/$(call mk_get,BUILD_DIR))

OUT_TYPE_doc          ?= type of built binary: $(call mk_opt_set,OUT_TYPE)
OUT_TYPE_default       = $(firstword $(mk_OUT_TYPE_list))
mk_OUT_TYPE            = $(call mk_get,OUT_TYPE)

OUT_DIR_doc           ?= output directory for effective output file(s)
OUT_DIR_default        = $(mk_BUILD_DIR)
mk_OUT_DIR             = $(call mk_get,OUT_DIR)

OUT_NAME_doc          ?= the base name of the final result
OUT_NAME_default       = outname
mk_OUT_NAME            = $(call mk_get,OUT_NAME)

OUT_FILE_NAME_doc     ?= the file name of the final result
OUT_FILE_NAME_default  = $(__out_file_name)
mk_OUT_FILE_NAME       = $(call mk_get,OUT_FILE_NAME)
mk_OUT_FILE_NAME_SO    = $(call mk_get,OUT_FILE_NAME)$(mk_MAYOR)$(mk_MINOR)
__out_file_name        = $(call __out_file_name_of,$(mk_OUT_NAME).$(mk_TAG),$(mk_OUT_TYPE))
__out_file_name_of     = $(call __out_file_name_$2,$1)
__out_file_name_exe    = $(1)
__out_file_name_static = lib$(1).a
__out_file_name_shared = lib$(1).so

OUT_FILE_doc          ?= path and file name of the final result
OUT_FILE_default       = $(mk_OUT_DIR)/$(mk_OUT_FILE_NAME)
mk_OUT_FILE            = $(call mk_get,OUT_FILE)
mk_OUT_FILE_SO         = $(call mk_get,OUT_FILE)$(mk_MAYOR)$(mk_MINOR)

OUT_UMASK_doc         ?= the umask to set for the final output file
mk_OUT_UMASK           = $(call mk_get,OUT_UMASK)

MAYOR_doc             ?= mayor version number
MAYOR_default          = 0
mk_MAYOR               = .$(call mk_val,MAYOR)

MINOR_doc             ?= minor version number, e.g. svn revision
MINOR_default          = $(svn_revision)
mk_MINOR               = .$(call mk_val,MINOR)

SOURCE_DIRS           ?= $(call scan_source_dirs,.)
mk_SOURCE_DIRS         = $(call mk_get,SOURCE_DIRS)
mk_IGNORE_DIRS         = $(call mk_get,IGNORE_DIRS)

SOURCE_FILES.%        += $(scan_source)
mk_SOURCE_FILES        = $(filter-out $(mk_IGNORE_FILES),$(call mk_get,SOURCE_FILES) $(mk_VARIANT_SOURCE))
mk_IGNORE_FILES        = $(call mk_get,IGNORE_FILES)
mk_VARIANT_FILES       = $(call mk_get,VARIANT_FILES)
mk_VARIANT_SOURCE      = $(call map,mk_variant_of,$(mk_VARIANT_FILES))
mk_VARIANT_PAIRS       = $(foreach f,$(mk_VARIANT_FILES),$(abspath  $f) $(call mk_variant_of,$f))

mk_OBJECTS             = $(call mk_object_of,$(mk_SOURCE_FILES))

mk_CLEARED_FILES      += $(CLEARED_FILES) $(mk_VARIANT_SOURCE)

SUBPACKAGES_doc       ?= directory list of project prerequisites
mk_SUBPACKAGES         = $(call mk_get,SUBPACKAGES)

mk_sub_makeflag        = $(if $(call seq,$1,BUILD_MODE),$(subst exe,static,$(mk_$1)),$(mk_$1))
mk_MAKEFLAGS           = $(foreach t,$(mk_OPT_CLASSES),$t=$(call mk_sub_makeflag,$t)) OUT_DIR=$(abspath $(mk_BUILD_DIR)) OUT_TYPE=static

mk_BINARY_TAG          = $(call mk_get,BINARY_TAG)
mk_BINARY_TAG_len      = $(call mk_lines,$(mk_BINARY_TAG))
mk_BINARY_TAG_frame    = $(if $(mk_BINARY_TAG),\
                              \n $(mk_BINARY_TAG)                       \n\
                              tail -$(call plus,$(mk_BINARY_TAG_len),2) \n\
                              head -$(mk_BINARY_TAG_len)\n,)

#-- targets --

.DEFAULT_GOAL = help
.SECONDEXPANSION:
.DELETE_ON_ERROR:
.PHONY: $(mk_TARGET_list) $(mk_CFG_list) built


$(DEPS_): $(MAKEFILE_LIST)
	@mkdir -p $(mk_BUILD_DIR) #<  ensure build dir explicitly - can't do this by prerequisite, as its time stamp changes!
	@touch $@                 #<  just touch empty deps file to prevent endless make in project root
	$(eval ___at_work := $(call seq,$(call mk_norm_dir,$(dir $@)),$(mk_BUILD_DIR)))
	@# create links to variant files ...
	$(if $(___at_work),$(call mk_link,$(mk_VARIANT_PAIRS)))
	@# write source file list to temporary file
	@#   and make sure all source files exist BEFORE running dependency analysis ...
	$(eval ___src := $(mk_SOURCE_FILES))
	@$(if $(and $(___at_work),$(___src)),                 \
	  	$(call mk_file,$(mk_SOURCE_LIST_FILE),$(___src))  \
	   	$(call mk_submake,--quiet,$(___src)))
	@# if source list file exists and is not empty, start dependency analysis ...
	@if [ -n "$(___at_work)" -a -s "$(mk_SOURCE_LIST_FILE)" ]; then \
		$(call mk_log,'$(call mk_frame,building deps $(call mk_DEPS_info,$@))',,renew) ;\
		$(foreach cmd,$(cmd_depends),$(call $(cmd),$(mk_DEPS),$(mk_SOURCE_LIST_FILE))) ;\
	fi
	@# check and warn if multiple source files map to a single object file ...
	$(eval ___multi_src_objects := $(call mk_list_multisource,. . . . >>))
	@if [ -n "$(and $(___at_work),$(___multi_src_objects))" ]; then  \
  	$(call mk_log,\nWARNING: Your makefile effectively specifies multiple source files yielding the same object!                              \
	  	            \n         For compiling the following objects make will consider only the first source file:\n\n $(___multi_src_objects)) ;\
		read -p "press ENTER to continue"                                                                                                        ;\
	fi


built_doc = target for starting build process
built: mk_tgt_chk_opts $$(patsubst %,%\/,$$(mk_OUTPUT_DIRS))
	$(call mk_packages,built)
	@$(MAKE) DEPS_=$(mk_DEPS) OUT_='$(mk_OUT_FILE)' $(mk_OUT_FILE)


$(OUT_): $$(mk_OBJECTS)
	@rm -f $@
	@$(call mk_log,'$(call mk_frame,linking target)')
	@$(cmd_LINK)
	@$(call mk_log)
	@if [ -e "$@" ]; then                                      \
		if [ -n "$(mk_BINARY_TAG)" ]; then                       \
			$(call mk_log,'$(call mk_frame,tagging binary $@)')   ;\
			$(call mk_log,$(mk_BINARY_TAG_frame),-n) | tee -a $@  ;\
		fi                                                      ;\
		if [ -n "$(mk_OUT_UMASK)" ]; then                        \
			chmod $(mk_OUT_UMASK) $@                              ;\
		fi                                                      ;\
		$(call mk_log)                                          ;\
		$(call mk_log,'$(call mk_frame,built successfully)')    ;\
	fi
	

$(mk_CFG_list):
	@$(MAKE) CFG=$@ built


clean_doc = clear build directory [$(mk_BUILD_DIR)] by removing object files
clean:
	$(call mk_packages,clean)
	@rm -f $(mk_CLEARED_FILES) $(mk_LOG_FILE) $(mk_DEPS)


grep,*_doc = grep pattern in source files: make grep,PATTERN[,GREP-OPTS]; default: GREP-OPTS: -iw
__grep     = grep $(or $(wordlist 2,$(words $1),$1),-iw) $(firstword $1)
grep,%:
	$(if $(call seq,grep$(mk_COMMA).o,$@),$(error USAGE: $(grep,*_doc)))
	-@GREP_OPTIONS=--color=auto $(call __grep,$(call mk_ssv,$*)) $(mk_SOURCE_FILES)


VPATH = $(subst $(mk_SPACE),:,$(mk_SOURCE_DIRS))

-include $(DEPS_)

endif # __mk_compilation_included

