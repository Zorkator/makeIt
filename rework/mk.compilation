
#-- set/modify public definitions --

mk_PARAMETERS   += CMPL TYPE ARCH CFG TAG BUILD_DIR OUT_DIR OUT_NAME OUT_FILE_NAME OUT_FILE
mk_TAG_CLASSES  += CMPL TYPE ARCH CFG mk_ANY
mk_TARGETS      += clean $(CONFIGURATIONS) #$(__sub_dirs)
mk_FILE_TYPES   += 
mk_TYPES        += exe static shared
mk_OUTPUT_DIRS  += $(BUILD_DIR)
mk_SUB_LIBS     += $(__sub_libraries)

mk_tagged        = $(foreach c,$(sort $(mk_TAG_CLASSES)),$($(1).$($(c))))
mk_tagged_file   = $(call mk_tagged,$(notdir $(1)))
mk_object_of     = $(patsubst %,$(BUILD_DIR)/%.o,$(notdir $(basename $(1))))

any_source       = $(foreach t,$(mk_FILE_TYPES),$(wildcard *.$(t)))
any_source_in    = $(foreach t,$(mk_FILE_TYPES),$(wildcard $(1)/*.$(t)))


#-- user parameters --

CONFIGURATIONS     ?= debug release
debug_doc          ?= target for building with debug options
release_doc        ?= target for building with optimization and without debug options

CMPL               ?= $(firstword $(mk_COMPILERS))
CMPL_doc           ?= name of compiler: {$(call mk_csv,$(mk_COMPILERS))}

TYPE               ?= $(firstword $(mk_TYPES))
TYPE_doc           ?= build type: {$(call mk_csv,$(mk_TYPES))}

ARCH               ?= $(firstword $(mk_ARCHITECTURES))
ARCH_doc           ?= architecture id: {$(call mk_csv,$(mk_ARCHITECTURES))}

CFG                ?= $(firstword $(CONFIGURATIONS))
CFG_doc            ?= name of build configuration: {$(call mk_csv,$(CONFIGURATIONS))}

TAG                ?= $(CMPL).$(ARCH).$(CFG)
TAG_doc            ?= string for tagging build directory. default: <CMPL>.<ARCH>.<CFG>

BUILD_DIR          ?= $(TAG).$(TYPE)
BUILD_DIR_doc      ?= working directory for building object files. default: <TAG>.<TYPE>

OUT_DIR            ?= $(BUILD_DIR)
OUT_DIR_doc        ?= output directory for putting the output file(s)

OUT_NAME           ?= outname
OUT_NAME_doc       ?= the base name of the final result

OUT_FILE_NAME      ?= $(__out_file_name)
OUT_FILE_NAME_doc  ?= the file name of the final result

OUT_FILE           ?= $(OUT_DIR)/$(OUT_FILE_NAME)
OUT_FILE_doc       ?= path and file name of the final result


#-- targets --

.PHONY: $(mk_TARGETS)

__rule_tmpl = "$(BUILD_DIR)/%.o: <type>\\n	@$1\\n"
_sdirs = $(sort $(dir $(__source_files)))
_tp    = $(foreach t,$(mk_FILE_TYPES),$(foreach d,$(_sdirs),$(d)%.$t))
_xp    = $(foreach d,$(_sdirs),$(d)%.$t)

build:
	#-- write auto-depends
	@$(shell echo $(OUT_FILE): $(sort $(mk_OUTPUT_DIRS:%=%\\/)) $(mk_OBJECTS) > $(__deps))
	@$(shell echo "	#>> linking ..."                                          >> $(__deps))
	@$(shell echo "	\$(mk_DOLLAR)(cmd_LINK)"                                  >> $(__deps))
	@$(shell echo "	#>> success"                                              >> $(__deps))
	@$(foreach f,$(__source_files),$(shell echo $(call mk_object_of,$f): $f              >> $(__deps)))
	@$(MAKE) $(OUT_FILE)
	#@rm $(__deps)


#$(__sub_dirs):
#	@cd $@ && $(MAKE) OUT_NAME=$@ OUT_DIR=../$(OUT_DIR)

__eval = $(call $(firstword $1),$(wordlist 2,99,$1))
eval.%:
	@echo $(call __eval,$(call mk_ssv,$*))


$(CONFIGURATIONS):
	$(MAKE) CFG=$@

clean_doc = clear build directory [$(BUILD_DIR)] by removing object files
clean:
	@rm -f $(mk_OBJECTS) $(LOG_FILE)
	#$(foreach d,$(__sub_dirs),$(shell cd $d && $(MAKE) clean))


#-- set/derive private variables/lists --

__deps := .mk.deps

__out_file_name_static = lib$(OUT_NAME).$(TAG).a
__out_file_name_shared = lib$(OUT_NAME).$(TAG).so
__out_file_name_exe    = $(OUT_NAME).$(TAG)
__out_file_name        = $(__out_file_name_$(TYPE))

__ignored_files   = $(IGNORE_FILES) $(call mk_tagged,IGNORE_FILES)
__source_files    = $(filter-out $(__ignored_files),$(SOURCE_FILES) $(call mk_tagged,SOURCE_FILES))
mk_OBJECTS        = $(call mk_object_of,$(__source_files))

#__sub_dirs           = $(SUB_DIRS) $(call mk_evalClasses,$(SUB_DIRS))
#__sub_libraries      = $(foreach s,$(__sub_dirs),$(s).$(TAG))

#__src_file_dirs      = $(foreach d,$(sort $(dir $(__filtered_src_files))),$d%) ./%
#__src_file_patterns  = $(foreach t,$(mk_FILE_TYPES),.$t)
#__rule_patterns      = $(shell echo {$(call mk_csv,$(__src_file_dirs))}{$(call mk_csv,$(__src_file_patterns))})
#__append_rule_to     = $(shell echo -e "$(BUILD_DIR)/%.o: $(1)\\n\\t@echo \$(mk_DOLLAR)@ \$(mk_DOLLAR)<" >> $(2))
#__append_rules       = $(foreach p,$(__rule_patterns),$(call __append_rule_to,$p,$(1)))
#
##__rule_tab           = $(foreach p,$(__rule_patterns),"$(BUILD_DIR)/%.o: $p\\n\\t@echo \$(mk_DOLLAR)@ \$(mk_DOLLAR)<\\n")
##__rule               = $(shell echo -e $(__rule_tab) > test.out)
##__mk_rules           = $(call __append_rules,test.out)
#
##__rule_f              = $(call __rule_pattern_of,f)
#__rule_pattern_of     = $(shell echo {$(call mk_csv,$(__src_file_dirs))}.$(1))
#__rules               = $(sort $(foreach t,$(mk_FILE_TYPES),$(call __rule_pattern_of,$t)))

sinclude $(__deps)
include $(MAKEIT_DIR)/mk.base
include $(MAKEIT_DIR)/mk.log

