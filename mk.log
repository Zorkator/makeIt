
ifndef __mk_log_included
__mk_log_included := true

include $(dir $(lastword $(MAKEFILE_LIST)))mk.base

mk_PARAMETERS  += LOG LOG_FILE
mk_TARGET_list += log

# $(mk_log,MESSAGE_STRING,[ECHO-OPTS],[renew])
define mk_log
	$(mk_echo) $2 '$1' $(call __log,$3)
endef

# $(mk_logged_cmd,CMD_STRING,[ECHO-OPTS],[renew])
# NOTE: In order to NOT losing the commands return status by writing the log, the given command is executed in a subshell.
#       Its output and return status are kept in variables __out and __stat.
#       For restoring the exit status we just test the stored status again after writing the log.
define mk_logged_cmd
	$(call mk_log,$(strip $1))
	 __out=$$($1 2>&1)                     ;\
	 __stat=$$?                            ;\
	 $(mk_echo) "$$__out" $(call __log,$3) ;\
	 [ $$__stat -eq 0 ]
endef 

#-- parameters ...

mk_LOG_list       = on off
LOG_doc          ?= switch to enable/disable logging: $(call mk_opt_set,LOG)
LOG_default       = $(firstword $(mk_LOG_list))
mk_LOG            = $(call mk_get,LOG)


LOG_FILE_doc     ?= file for logging build messages.
LOG_FILE_default  = $(mk_BUILD_DIR)/_log.txt
mk_LOG_FILE       = $(call mk_get,LOG_FILE)

#-- targets ...

log_doc = show the logged command output via less
log:
	@if [ -e "$(mk_LOG_FILE)" ]; then                 \
		less $(mk_LOG_FILE)                            ;\
	else                                              \
		$(mk_echo) No log so far. Need to build first! ;\
	fi


#-- definitions for build step logging ...

__log_on  = | tee $(if $1,,-a) $(abspath $(mk_LOG_FILE))
__log_off =
__log     = $(call __log_$(mk_LOG),$1)

endif # __mk_log_included

