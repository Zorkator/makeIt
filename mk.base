
ifndef __mk_base_included
__mk_base_included := true

__mk_root := $(dir $(lastword $(MAKEFILE_LIST)))

include  $(__mk_root)mk.log
sinclude $(__mk_root)gmsl/gmsl

__cmd_max_args := 512

#-- set/modify public definitions --

mk_PARAMETERS  += 
mk_CFG_list    +=
mk_TARGET_list += help echo,* eval,* value,*

mk_NULL       :=
mk_SPACE      := $(mk_NULL) #
mk_COMMA      := ,
mk_DOLLAR     := $$
mk_ANY        := %

mk_ignoreErrors  := 2> /dev/null || :
mk_echo          := /bin/echo -e
mk_now            = $(shell date '+%d.%m.%Y %T')
mk_prompt         = $(shell read -p "$(if $1,$1,press ENTER to continue) " x && echo "$$x")
mk_pwd            = $(abspath .)
mk_path           = $(join $(dir $1),$(notdir $1))
mk_norm_dir       = $(patsubst %/,%,$1)
mk_args           = $1$2$3$4$5$6$7$8$9\n
mk_error          = $(error $1)
mk_warning        = $1\n$(warning $1)
mk_count          = $(words $(filter $1,$2))
mk_substring      = $(if $(findstring $1,$2),$2,)
mk_grep           = $(strip $(foreach x,$2,$(call mk_substring,$1,$x)))
mk_lower          = $(shell echo $(1) | tr A-Z a-z)#<                                          mk_lower( sTriNg )                 : string
mk_upper          = $(shell echo $(1) | tr a-z A-Z)#<                                          mk_upper( sTriNg )                 : STRING
mk_csv            = $(subst $(mk_SPACE),$(mk_COMMA),$(strip $1))#<                             mk_csv( v1 v2 ... )                : v1,v2,...
mk_lsv            = $(subst $(mk_SPACE),\\n,$(strip $1))#<                                     mk_lsv( v1 v2 ... )                : 'v1\nv2\n...'
mk_join           = $(subst $(mk_SPACE),$1,$(strip $2))#<                                      mk_join( S, v1 v2 ... )            : 'v1Sv2S...'
mk_ssv            = $(subst $(mk_COMMA),$(mk_SPACE),$(strip $1))#<                             mk_ssv( 'v1,v2,...' )              : 'v1 v2 ...'
mk_reverse        = $(if $1,$(call mk_reverse,$(wordlist 2,$(words $1),$1)) $(firstword $1))#< mk_reverse( v1 v2 ... )            : ... v2 v1
mk_defined        = $(patsubst undefined,,$(origin $1))#<                                      mk_defined( varId )                : origin(varId) | ''
mk_var            = $(if $(call mk_defined,$1),\\$($1),)#<                                     mk_var( varId )                    : \\$(varId) | ''
mk_val            = $(or $($1),$($1_default))#<                                                mk_val( varId )                    : val | default | ''
mk_map            = $(foreach i,$2,$(call $1,$i))#<                                            mk_map( func, v1 v2 ... )          : res1 res2 ...
mk_lines          = $(shell $(mk_echo) "$1" | wc -l)#<                                         mk_lines( string )                 : num of lines
mk_opt_set        = {$(call mk_csv,$(call uniq,$(mk_$1_list)))}#<                              mk_opt_set( optID )                : base name of option list
mk_unsigned       = $(patsubst -%,%,$1)#<                                                      mk_unsigned( -v1 v2 -v3 )          : v1 v2 v3
mk_disabled       = $(patsubst -%,%,$(filter -%,$1))#<                                         mk_disabled( -v1 v2 -v3 )          : v1 v3
mk_enabled        = $(filter-out $(call mk_disabled,$1),$(call mk_unsigned,$1))#<              mk_enabled( -v1 v2 v3 )            : v2
mk_selective      = $(call uniq,$(call mk_enabled,$1))#<                                       mk_selective( v1 v2 v3 -v1 )       : v2 v3
mk_file_list      = $(call $1,$(foreach t,$2,%.$t),$3)#<                                       mk_file_list( func, extensions, filelist )

mk_match          = ${shell case $1 in $2) echo '$(value 3)';; *) ;; esac}#<                   mk_match( text, pattern, res )     : res | ''
mk_matchRE        = ${shell if expr $1 : $2 > /dev/null; then echo '$(value 3)'; fi}#<         mk_matchRE( text, re_pattern, res ): res | ''
mk_pattern_opts   = $(foreach p,$($1),$(call mk_match,$2,$p,$($p)))#<                          mk_pattern_opts( PATTERN_list, text )
mk_patternRE_opts = $(foreach p,$($1),$(call mk_matchRE,$2,$p,$($p)))#<                        mk_patternRE_opts( PATTERN_RE_list, text )

# $(call mk_xargs,COMMAND,LIST[,NUM])
define mk_xargs
	$(eval ___num  := $(or $3,$(__cmd_max_args)))
	$(eval ___next := $(call plus,1,$(___num)))
	$1 $(wordlist 1,$(___num),$2)
	$(if $(word $(___next),$2),$(call mk_xargs,$1,$(wordlist $(___next),$(words $2),$2),$(___num)))
endef

# $(call mk_file,FILENAME,LIST,[append])
define mk_file
	: $(if $(and $2,$3),,>$1)
	$(call mk_xargs,printf "%s\n" >>$1,$2,$(__cmd_max_args))
endef

# $(call mk_submake,ARGS,TARGETLIST,[NUM])
define mk_submake
	$(if $2,$(call mk_xargs,$(MAKE) $1,$2,$(or $3,$(__cmd_max_args))))
endef

# $(call mk_link,TGT_NAME_PAIRS)
define mk_link
	$(if $(call gt,$(words $1),1),$(call mk_xargs,ln -sf,$1,2))
endef

# $(call mk_frame,STRING)
define mk_frame
	$(eval ___line := $(subst x ,-,$(call int_encode,$(call plus,4,$(call strlen,$1))) ))\
	'$(___line)\n ] $1 [\n $(___line)'
endef

#-- targets --

help_doc = print overview over supported parameters and targets
help:
	@$(mk_echo) ' $(TARGET_doc)           \n\n' \
              '== KNOWN CONFIGURATIONS == \n' \
              '$(__cfg_tab)               \n' \
              '== OTHER TARGETS ==        \n' \
              '$(__tgt_tab)               \n' \
              '== CURRENT PARAMETERS ==   \n' \
              '$(__var_tab)'


help,*_doc = echo value of make variable and specify its origin, e.g. make origin.CFG
help,%:
	@$(mk_echo) $* = [$(origin $*)] $($*)


echo,*_doc = evaluate value of make variable 
echo,%:
	@$(mk_echo) "$(subst \n,\\n,$($*))"


eval,*_doc = evaluate a make variable by calling with argument, e.g. make eval._mkFunc,arg. Separate directories by \\\\.
__eval     = $(call $(firstword $1),$(subst \,/,$(wordlist 2,$(words $1),$1)))
eval,%:
	@$(mk_echo) '$(subst \n,\\n,$(call __eval,$(call mk_ssv,$*)))'


value,*_doc = show value of make variable
value,%:
	@$(mk_echo) '$(subst \n,\\\\n,$(value $*))'


mk_tgt_chk_opts:
	@$(mk_echo) '$(call __var_tab)' >> /dev/null


%/:
	@mkdir -p $@


#-- private definitions --

__var_line = $(shell printf '%-16s %-12s  %-60s  %s\\n' '$1' '$(subst undefined,default,$(origin $1))' '$($(1)_doc)' '$(subst $$,"$$",$(strip $(mk_$1)))')
__var_chk  = $(if $(mk_$1_list),$(filter $(mk_$1),$(mk_$1_list)),ok)
__var_doc  = $(if $(call __var_chk,$1),$(call __var_line,$1),$(error option variable $1 is set to unknown value "$($1)"))
__var_tab  = $(call mk_map,__var_doc,$(sort $(mk_PARAMETERS)))

__tgt_doc = $(shell printf '%-10s %s\\n' '$1' '$($(1)_doc)')
__tgt_tab = $(call mk_map,__tgt_doc,$(sort $(mk_TARGET_list)))
__cfg_tab = $(call mk_map,__tgt_doc,$(sort $(mk_CFG_list)))

endif # __mk_base_included

